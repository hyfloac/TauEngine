# Tau Reflection Generator

A small tool inspired by Unreal Engine's Header Tool for automatically generating reflection information. 

This uses Clang's LibTooling to help with the parsing. First it has a preprocessor callback that will record every time one of our macros is expanded. The tool will keep track of the source location and will process all of its attributes. Each instance is pushed into a queue. Then later when walking the AST we look at every time a field is declared, check to see if it is after a property macro; if it is we will pop off that macro from the queue, then insert the property into the list of properties for that class, now with the properties name and type. 

After all of the file has been parsed it will generate a new file (currently fixed in the code) which will contain the macro `TAU_GENERATED_BODY(_CLASS)`.  We take the class name as a parameter to prevent compilation errors, if we directly called `TAU_GENERATED_BODY_Test()` then the preprocessor would fail because it can't find that macro, and it's very difficult to generate that macro based on class name before parsing. Thus we use a small hack to have `TAU_GENERATED_BODY(_CLASS)` redirect to `_TAU_GENERATED_BODY_##_CLASS()` after the code has been generated. These class specific macros will contain an entire class, implementing the reflection class, as well as a static function containing a static instance of the new class, and an instance function for getting the class, which will forward its call to the static function.

Attributes have a chance to generated code custom code for each class. They are passed in the entire set of properties and it is their job to find the properties that they need and generate the proper code for them. Currently there is only `get` and `set` attributes implemented.

## Interface

Currently you can use `TAU_PROPERTY()` macros directly before a field declaration and specify `get` and/or `set` in the argument list. At some point in the class you need to call the macro `TAU_GENERATED_BODY(_CLASS)`. The class must also be tagged with `TAU_CLASS()`.

You can also use `TAU_FUNCTION()` tags before member functions. Currently there aren't any attributes implemented, but the system has been designed to be easy to extend.

After everything's been generated you can either call `GetStaticClass()` on the type or `getClass()` on the instance to get an instance of reflection class. Within that you have a variety of functions at your disposal generated by the various attributes. The current base implementation has a couple of variations on `getProperty(_T* object, const char* propertyName)`, mainly some templates to have the function return a specific type, and some differentiation between `const` and non-`const` data. There is also specific `setProperty` functions that don't let the client read the value.

## Extending

### Attributes

Adding attributes is a rather straight forward process. You just need to add a little bit of parsing for your arguments, and some simple code generation. After that you just have to register the attribute.

```c++
#include "reflection/Attribute.hpp"

class ExampleAttribute final : public tau::reflection::IAttribute
{
public:
    [[nodiscard]] bool isForClass() const noexcept override { return true; }
    
    AttributeData parseAttribute(const DynString& attribName, const ::clang::MacroArgs* args, const ::clang::Token*& currentToken) const noexcept
    {
        cuurrentToken = getNextToken(currentToken);
        
        void* customData = nullptr;
        return AttributeData(this, customData, attribName);
    }
    
    void generateImplTauClass(::llvm::raw_fd_ostream& base, cosnt Ref<Class>& clazz) const noexcept override
    {
        // Code generation for the reflection class.
    }
};
```

You have complete control over how the attribute arguments are parsed. As long as Clang can lex them as valid token, you can parse them in any manner. You are also given a chance to add some custom data for use with your code generators. If you do add the custom data make sure to implement the `destroyData` function to release the memory.

For code generation you can use `generateBaseTauClass` which will let you generate code in `TauClass` in base header. Use `generateImplTauClass` to implement the methods that you put into the base class. Use `generateImplClass` to inject functions or data into the original type.



After that you just need to register the attribute.

```c++
tau::reflection::AttributeManager::registerAttribute<tau::reflection::attribs::ExampleAttribute>("ex");
```

